Functional Programming Principles in Scala
==========================================

Week 1
======

Functions and Evaluation
========================

Programming Paradigms
---------------------
Paradigm describes distinct concepts or thought patterns in some scientific
  discipline.

Main programming paradigms:
a. imperative programming
b. functional programming
c. logic programming

Orthogonal to it:
a. object-oriented programming

Imperative programming:
It is about
a. modifying mutable variables
b. using assignments
c. and control structures such as if-else, loops, break, continue, return.

Functional Programming (FP):
Restricted sense: Programming without mutable variables, assignments, loops,
  and other imperative control structures
Wider sense: functional programming means focusing on the functions

In particular, functions can be values that are produced, consumed, and
  composed.

Functions in a FP language are first class citizens.
This means
a. they can be defined anywhere, including inside other functions.
b. like any other value, they can be passed as parameters to functions and
  returned as results.
c. as for other values, there exists a set of operators to compose functions.

Some FP languages:
a. Restricted sense
Pure Lisp, XSLT, XPath, XQuery, FP
Haskell (without I/O Monad or UnsafePerformIO)

b. Wider sense
Lisp, Scheme, Racket, Clojure
SML, Ocaml, F#
Haskell (full language)
Scala
Smalltalk, Ruby

Recommended book:
Programming in Scala (Martin Odersky)

FP is becoming popular because
a. simpler reasoning principles
b. better modularity
c. good for exploiting parallelism for multicore and cloud computing

Elements of Programming
-----------------------

Every non-trivial programming language provides:
a. primitive expressions representing the simplest elements.
b. ways to combine expressions
c. ways to abstract expressions, which introduce a name for an expression

FP provides interactive shell (REPL: Read-Eval-Print-Loop)
	$ scala
	$ sbt console

Parameter and Return types:
Function parameters comes with their type, which is give after the colon
	$ def power(x: Double, y: Int): Double = ...

If a return type is given, it follows the parameter list

Evaluation of function applications is done via substition model, which gives 
  foundation to FP.

Call-by-value (CBV) has the advantage that it evaluates every function argument 
  only once.
Call-by-name (CBN) has the advantage that a function argument is not evaluated 
  if the corresponding parameter is unused in the evaluation of the function
  body.

Evaluation Strategies and Termination
-------------------------------------

If CBV evaluation of an expression e terminates, then CBN evaluation of e
  terminates too.
The other direction is not true.

Scala normally uses CBV.
But, if the type of a function parameter starts with => it uses CBN

Conditionals and Value Definitions
----------------------------------

Scala has if-else conditional expression.

For e.g
	$ def abs(x: Int) = if (x > 0) x else -x

Value Definitions:
The def form is "by name", its right hand side is evaluated on each use.
The val form is "by value", its right hand side is evaluated at the point of
  definition itself.

For e.g
	$ def loop: Boolean = loop

A definition
	$ def x = loop # will terminate

But,
	$ val x = loop # will lead to infinite loop

Example: Square roots with Newtons' method
------------------------------------------

  $ def sqrtIter(guess: Double, x: Double): Double = 
	   if (isGoodEnough(guess, x)) guess
	   else sqrtIter(improve(guess, x), x)

Recursive functions need an explicit return type in scala.

Blocks and Lexical Scope
------------------------

Put auxciliary functions inside function which is using it to avoid user to
  access these functions directly.

Blocks:
a. A block is delimited by braces { ... }
b. It contains a sequence of definitions or expressions
c. The last element of a block is an expression that defines its value
d. This return expression can be preceded by auxiliary definitions.
e. Blocks are themselves expressions.

Visibility:
a. The definitions inside a block are only visible from within the block.
b. The definitions inside a block shadow definitions of the same name outside
  the block.

Semicolons:
In Scala, semicolons at the end of lines are in most cases optional, but if
  there are more than one statements on a line, they need to be separated by
  semicolons.

Handle problem in writing huge multi-line expressions:
a. Use multi-line expressions in parentheses
b. Use operator on the first line

Tail Recursion
--------------

In call by value, the occurences of param of a function get replaced by the
  value of the param passed during calling.
This is called substitution.

If a function calls itself as its last action, the function's stack frame can
  be reused. This is called tail recursion.
Tail recursive functions are iteractive processes.

In general, if the last action of a function consists of calling a function
  (which may be the same), one stack frame would be sufficient for both
  functions. Such calls are called tail-calls.

In Scala, only directly recursive calls to the current functions are optimized.

Use @tailrec annotation, which will issue an error if implementation of a
  function is not tail recursive.

Week 2
======

Higher Order Functions
======================

Higher Order Functions
----------------------

In contrast to first order functions, which has datatypes as parameters,
  functions that take other functions as parameters or that return functions as
  results are caller Higher Order Functions.
This provides a flexible way to compose programs.

For e.g
Take the sum of the integers between a and b:

	$ def sumInts(a: Int, b: Int): Int =
		  if (a > b) 0 else a + sumInts(a+1, b)

This is special case of
Sigma f(n) for n = a to b

We can also write:

	$ def sum(f: Int => Int, a: Int, b: Int): Int =
		  if (a > b) 0 else f(a) + sum(f, a+1, b)

	$ def id(x: Int): Int = x

	$ def sumInts(a: Int, b: Int) = sum(id, a, b)

Here, sum function is a higher order function.

Passing functions as parameters leads to the creation of many small functions.
  In order to overcome this, we'll write a function without giving it a name,
  which are otherwise called anonymous functions.

For e.g
  
  $ (x: Int) => x * x * x

Here, (x: Int) is the parameter of the function, and x * x * x is the body.

Using annonymous functions:

  $ def sum(f: Int => Int, a: Int, b: Int): Int =
    if (a > b) 0 else f(a) + sum(f, a+1, b)

  $ def sumInts(a: Int, b: Int) = sum(x => x, a, b)

This is using linear recursion, but we can optimized it using tail recursion.

  $ def sum(f: Int => Int, a: Int, b: Int): Int = {
      def loop(acc: Int, x: Int): Int = {
        if (x > b) acc
        else loop(f(x) + acc, x + 1)
      }
      loop(a, 0)
    }

  $ sum(x => x, 1, 10)

Currying
--------

Functions returning functions.

For e.g

  $ def sum(f: Int => Int): (Int, Int) => Int = {
      def sumF(a: Int, b, Int): Int = {
        if (a > b) 0
        else f(a) + sumF(a + 1, b)
      }
      sumF
  }

Hence, we can define

  $ def sumInts = sum(x => x)

Which gives us capability to do

  $ sumInts(2, 3)

Which can be also written as

  $ sum(x => x)(2, 3)

In scala, we can define functions returning functions as follows:

  $ def sum(f: Int => Int)(a: Int, b: Int): Int =
      if (a > b) 0 else f(a) + sum(f)(a + 1, b)

Here, function type of sum is

  (Int => Int) => (Int, Int) => Int

In general:

  $ def f = (args1 => (args2 => ... (argsn => E) ... ))

This style of definition and function application is called currying.

Example: Finding fixed points
-----------------------------

The expressive power of a language is greatly increases if we can pass
  function arguments.

Functions are essential abstractions because they allow us to introduce
  general methods to perform computations as explicit and named elements
  in our programming language.

Abstractions can be combined with higher-order functions to create new
  abstractions.

Scala Syntax Summary
--------------------

Contex-free syntax in Extended Backus-Naur Form (EBNF), where
  | denotes an alternative
  [...] an option (0 or 1)
  {...} a repetition (0 or more)

Types:

Type = SimpleType | FunctionType
FunctionType = SimpleType '=>' Type | '(' [Types] ')' '=>' Type
Simpletype = Ident
Types = Type {',' Type}

For e.g
Numeric type: Int, Double
Function type: Int => Int, (Int, Int) => Int

Functions and Data
------------------

Classes and Objects.

Packaging functions operating on a data abstraction in the data abstraction
  itself. Such functions are called methods.

More Fun with Rationals
-----------------------

One can use 'val' or 'def' while defining fields in order to optimize code.
This ability to choose different implementations of the data without affecting
  clients is called data abstraction.

On the inside of a class, the name 'this' represents the object on which the
  current method is executed.

Use require function to put restrictions on the params.

'require' is a predefined function
It takes a condition and an optional message string.
If the condition passed to require is false, an IllegalArgumentException is
  thrown with the given message string.

Besides require, there is also assert.
Assert also takes a condition and an optional message string as parameters.

Assert throws 'AssertionError'.

This reflects a difference in intent:
a. require is used to enforce a precondition on the caller of a function.
b. assert is used as to check the code of the function itself.

Constructors:
In Scala, a class implicitly introduces a constructor. This one is called
  primary constructor of the class.

The primary constructor:
a. takes the parameter of the class
b. and executes all statements in the class body.

Use $ def this() to explicitly create a constructor.

Evaluation and Operators
------------------------

Class and objects also works using substitution method.
But, instead of one substitution, there are three for each method call.

Operators:
Step1: Infix Notation
Any method with a parameter can be used like an infix operator.
For e.g
Use r add s in place of r.add(s)

Step2: Relaxed Identifiers
Operators can be used as identifiers.
a. Alphanumeric
b. Symbolic
c. The underscore character '_'

Week 3
======

Data and Abstraction
====================

Class Heirarchies
-----------------

Abstract classes: can contain members which are missing an implementation.
No Instances of an abstract class can be created with the operator new.

Use 'extends' keyword to inherit abstract class and its methods.

If definition of method is already present in base class, one has to mention
  'override' keyword in subclass while re-definining the method.

One can contain Singleton object in order to restrict users to create more than
  one object of a class.

How classes are organised
-------------------------

Packages:
Classes and Objects are organised in packages.
To place a class or object inside a package, use package clause at the top
  of your source file.

Use import to use a class present in a different package in your current.
import package.class
import package.{class1, class2}
import package._

Some entities are automatically imported in any Scala program.
a. All members of package scala
b. All members of package java.lang
c. All members of the singleton object scala.Predef

Traits:
In Java, as well as in Scala, a class can only have one superclass.
One can use traits, which is declared like an abstract class, just with trait
  instead of abstract class.

Classes, Objects, and Traits can inherit from at most one class but arbitary
  many traits.
For e.g
  class Square extends Shape with Planar with Movable ...

Traits resembles interfaces in Java, but are more powerful because they can
  contain fields and concrete methods.

On the other hand, traits cannot have (value) parameters, only classes can.

Exceptions:
threw exce

Polymorphism
------------

Type parameters:
We can generalize class definition using a type parameter.
For e.g
trait List[T]
class Cons[T]

Like classes, functions can have type parameters.
For e.g
def singleton[T](elem: T) = ...

In fact, the Scala compiler can usually deduce the correct type parameters
  from the value arguments of a function call.

Type parameter do not affect evaluation in Scala.
This is called type erasure.

Polymorphism means that a function type comes "in many forms".
a. the function can be applied to arguments of many types.
b. the type can have instances of many types.

Two principal forms of polymorphism:
a. subtyping: instances of a subclass can be passed to a base class.
b. generics: instances of a function or class are created by type param.
